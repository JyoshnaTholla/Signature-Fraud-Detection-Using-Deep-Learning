# -*- coding: utf-8 -*-
"""MINI SFD  PROJECT .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1DUjsmgu-4j-VbcsdyziQZru7-5XOybHj
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import numpy as np
import skimage.io as sk
from skimage import img_as_ubyte
from skimage.io import imread
from scipy import spatial
from tensorflow.keras.layers import Dense, Flatten, Input, Lambda, MaxPooling2D, Conv2D, Dropout, BatchNormalization
from tensorflow.keras.models import Model
from tensorflow.keras.applications.resnet50 import ResNet50
from tensorflow.keras.preprocessing import image
from tensorflow.keras.preprocessing.image import ImageDataGenerator, load_img
from keras.models import Sequential
from glob import glob
import cv2
import matplotlib.pyplot as plt

from tensorflow.keras.layers import GlobalAveragePooling2D

base_model = ResNet50(weights='imagenet', include_top=False)
3
# Add custom top layers
x = base_model.output
x = GlobalAveragePooling2D()(x)
x = Dense(1024, activation='relu')(x)
predictions = Dense(1, activation='sigmoid')(x)

import skimage.io as sk
import matplotlib.pyplot as plt # Import the matplotlib.pyplot module

import skimage.io as sk


image1 = sk.imread("/content/drive/MyDrive/real/realimg.jpeg")
fig, ax = plt.subplots(1,5, figsize = (15,10))
ax[0].imshow(image1)
ax[0].set_title("Real_10")


image2 = sk.imread("/content/drive/MyDrive/forge/forgeimg.jpeg")
fig, ax1 = plt.subplots(1,5, figsize = (15,10))
ax1[0].imshow(image2)
ax1[0].set_title("Forge_10")

train_path = '/content/drive/My Drive/Real-Forg-Signature/Train'
test_path = '/content/drive/My Drive/Real-Forg-Signature/Test'

Image_Width = 512
Image_Height = 512
Image_Size = (Image_Width, Image_Height)
Image_Channel = 3
batch_size=15

model = Sequential()

## Conv layer 1
model.add(Conv2D(32, (3,3), activation='relu', input_shape=(Image_Width,Image_Height, Image_Channel)))
model.add(BatchNormalization())
model.add(MaxPooling2D(pool_size=(2,2)))
model.add(Dropout(0.25))

## Conv layer 2
model.add(Conv2D(64, (3,3), activation='relu'))
model.add(BatchNormalization())
model.add(MaxPooling2D(pool_size=(2,2)))
model.add(Dropout(0.25))

## Conv layer 3
model.add(Conv2D(128, (3,3), activation='relu'))
model.add(BatchNormalization())
model.add(MaxPooling2D(pool_size=(2,2)))
model.add(Dropout(0.25))

## Conv layer 4
model.add(Conv2D(256, (3,3), activation='relu'))
model.add(BatchNormalization())
model.add(MaxPooling2D(pool_size=(2,2)))
model.add(Dropout(0.25))

## Conv layer 5
model.add(Conv2D(256, (3,3), activation='relu'))
model.add(BatchNormalization())
model.add(MaxPooling2D(pool_size=(2,2)))
model.add(Dropout(0.25))

## Conv layer 6
model.add(Conv2D(512, (3,3), activation='relu'))
model.add(BatchNormalization())
model.add(MaxPooling2D(pool_size=(2,2)))
model.add(Dropout(0.25))

model.add(Flatten())
model.add(Dense(256,activation='relu'))
model.add(BatchNormalization())
model.add(Dropout(0.5))

model.add(Dense(2, activation='softmax'))

model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['accuracy'])

model.summary()

from keras.callbacks import EarlyStopping, ReduceLROnPlateau

early_stop = EarlyStopping(patience=10)
learning_rate_reduction = ReduceLROnPlateau(monitor='val_acc', patience=2, verbose=1, factor=0.5, min_lr=0.00001)
callbacks = [early_stop, learning_rate_reduction]

# Scaling all the images between 0 to 1 and applying Data Augmentation

train_datagen = ImageDataGenerator(rotation_range=15,
                                  rescale=1./255,
                                  shear_range=0.1,
                                  zoom_range=0.2,
                                  horizontal_flip=True,
                                  width_shift_range=0.1,
                                  height_shift_range=0.1,)

train_generator = train_datagen.flow_from_directory('/content/drive/My Drive/Real-Forg-Signature/Train',
                                              target_size=Image_Size,
                                              batch_size=32,
                                              class_mode = 'categorical')

# Performing only scaling on the test dataset

test_datagen = ImageDataGenerator(rescale=1./255)

import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator

test_generator = test_datagen.flow_from_directory('/content/drive/MyDrive/Real_Forge_Signature1/Test',
                                                  target_size=Image_Size,
                                                  batch_size = 32,
                                                  class_mode='categorical')

# Assuming 'model' is your Sequential model object

# Add a Flatten layer before your dense layers
model.add(tf.keras.layers.Flatten())

# Now add your Dense layers
model.add(tf.keras.layers.Dense(128, activation='relu'))
# ... rest of your dense layers ...

import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.preprocessing.image import ImageDataGenerator

model = Sequential([
    Conv2D(32, (3, 3), activation='relu', input_shape=(64, 64, 3)),
    MaxPooling2D((2, 2)),
    Conv2D(64, (3, 3), activation='relu'),
    MaxPooling2D((2, 2)),
    Conv2D(128, (3, 3), activation='relu'),
    MaxPooling2D((2, 2)),
    Flatten(),
    Dense(512, activation='relu'),
    Dropout(0.5),
    Dense(10, activation='softmax')  # Assuming 10 classes for classification
])

model.compile(optimizer=Adam(learning_rate=0.001),
              loss='categorical_crossentropy',
              metrics=['accuracy'])

train_datagen = ImageDataGenerator(rescale=1./255, shear_range=0.2, zoom_range=0.2, horizontal_flip=True)
test_datagen = ImageDataGenerator(rescale=1./255)

train_generator = train_datagen.flow_from_directory(
    '/content/drive/MyDrive/Real-Forg-Signature/Train',
    target_size=(64, 64),
    batch_size=32,
    class_mode='categorical'
)

test_generator = test_datagen.flow_from_directory(
    '/content/drive/MyDrive/Real-Forg-Signature/Train',
    target_size=(64, 64),
    batch_size=32,
    class_mode='categorical'
)

import tensorflow as tf
from tensorflow import keras

# Example: Defining a simple sequential model
model = keras.Sequential([
    keras.layers.Dense(64, activation='relu', input_shape=(784,)),
    keras.layers.Dense(10, activation='softmax')
])

# Compile the model
model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

# Display the model's architecture
model.summary()

model = Model(inputs=base_model.input, outputs=predictions)

model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

input_data = np.random.rand(1, 64, 64, 3)  # Batch size of 1

input_data_resized = tf.image.resize(input_data, (224, 224))

threshold = 0.5

from tensorflow.keras.applications import ResNet50

model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])

import numpy as np
 import tensorflow as tf
 input_data = np.random.rand(1, 224, 224, 3)  # Batch size of 1
input_data_resized = tf.image.resize(input_data, (224, 224))
input_data_resized = input_data_resized.numpy()

target_data = np.array([[0, 1, 0, 0, 0, 0, 0]])  # One-hot encoded target for multi-class classification

pred = model.predict(input_data_resized)
print("Prediction:", pred)
print("Prediction shape:", pred.shape)

predicted_class = np.argmax(pred, axis=-1)
print("Predicted class:", predicted_class)

from tensorflow.keras.models import load_model

model.save('forge_real_signature_model.h5')

from tensorflow.keras.models import load_model

model.save('my_model.keras')

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.datasets import mnist
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Flatten
from tensorflow.keras.utils import to_categorical

# Load the MNIST dataset
(train_images, train_labels), (test_images, test_labels) = mnist.load_data()

# Preprocess the data
train_images = train_images.reshape((60000, 28, 28, 1)).astype('float32') / 255  # Correct the shape of training images
test_images = test_images.reshape((10000, 28, 28, 1)).astype('float32') / 255   # Correct the shape of testing images
train_labels = to_categorical(train_labels)
test_labels = to_categorical(test_labels)

# Define the model
model = Sequential([
    Flatten(input_shape=(28, 28, 1)),
    Dense(512, activation='relu'),
    Dense(10, activation='softmax')
])

# Compile the model
model.compile(optimizer='adam',
              loss='categorical_crossentropy',
              metrics=['accuracy'])

# Fit the model and store the training history
history = model.fit(
    train_images, train_labels,
    epochs=4,
    batch_size=32,
    validation_data=(test_images, test_labels)
)

# Evaluate the model
test_loss, test_acc = model.evaluate(test_images, test_labels)
print(f'Test accuracy: {test_acc}')

import matplotlib.pyplot as plt

plt.figure(figsize=(10,7))
plt.plot(history.history['loss'], label='train loss')
plt.plot(history.history['val_loss'], label='val loss')
plt.plot(history.history['accuracy'], label='train_acc')
plt.plot(history.history['val_accuracy'], label='val_acc')
plt.title("Training Loss and Accuracy")
plt.legend()
plt.show()
plt.savefig('lossval_loss')

# Assuming 'test_generator' is meant to be a simple array of test images:
pred = model.predict(test_images)
print(pred)

import numpy as np

# Incorrect shape:
array = np.array([1, 2, 3])  # 1D array
# Trying to access the second element in each row (which doesn't exist)
result = array[1]  # Raises AxisError

# Corrected shape:
array = array.reshape(-1, 1)  # Reshape to 2D array
result = array[:, 0]  # Accesses the first element in each row

import os

# Define the base directory
base_dir = '/content/drive/My Drive/Real-Forg-Signature'

# Define the training and testing directories
train_dir = os.path.join(base_dir, 'Train')
test_dir = os.path.join(base_dir, 'Test')

# Define subdirectories for real and forged signatures
train_real_dir = os.path.join(train_dir, 'Real')
train_forged_dir = os.path.join(train_dir, 'Forged')
test_real_dir = os.path.join(test_dir, 'Real')
test_forged_dir = os.path.join(test_dir, 'Forged')

# Create the directories
os.makedirs(train_real_dir, exist_ok=True)
os.makedirs(train_forged_dir, exist_ok=True)
os.makedirs(test_real_dir, exist_ok=True)
os.makedirs(test_forged_dir, exist_ok=True)

print("Directories created successfully.")

from tensorflow.keras.preprocessing import image

img = image.load_img('/content/drive/MyDrive/Real-Forg-Signature/Train/Forged/forgeries_43_18.png', target_size=(512,512))

x = image.img_to_array(img)

x.shape

x = x/255

from tensorflow.keras.applications.resnet50 import preprocess_input

x=np.expand_dims(x,axis=0)
img_data=preprocess_input(x)
img_data.shape

from tensorflow.keras.applications.resnet50 import ResNet50
from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.resnet50 import preprocess_input
import numpy as np

# Load the pre-trained ResNet50 model
model = ResNet50(weights='imagenet')

# Load and preprocess the image
img_path = '/content/drive/MyDrive/Real-Forg-Signature/Train/Forged/forgeries_43_18.png'
img = image.load_img(img_path, target_size=(224, 224))  # ResNet50 expects 224x224 images
x = image.img_to_array(img)
x = np.expand_dims(x, axis=0)
x = preprocess_input(x)

model.predict(x)
x

a=np.argmax(model.predict(x), axis=1)

if(a==1):
    print("The signature is real")
else:
    print("The signature is fraud")

